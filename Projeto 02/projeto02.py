# -*- coding: utf-8 -*-
"""projeto02.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1uFKt7Tp3uaPHTQDhy-J4xVm7R7f0g7FT
"""

import time # Importa o módulo 'time' para medir o desempenho de execução.
import random # Importa 'random' para gerar dados de teste aleatórios.
import matplotlib.pyplot as plt # Importa 'matplotlib.pyplot' para criação de gráficos.

class Node:
    def __init__(self, valor): # Define o valor e os ponteiros para os filhos
        self.valor = valor # Inicializa o valor do nó
        self.esquerda = None # Inicializa o filho da esquerda como vazio
        self.direita = None # Inicializa o filho da direita como vazio


    def inserir(self, valor): # Método para inserir um novo valor na árvore
        if valor < self.valor: # Se o valor inserido for menor que o valor atual, deve ir para a esquerda
            if self.esquerda is None: # Se não houver filho à esquerda, cria um novo nó
                self.esquerda = Node(valor)
            else: # Caso já exista, chama recursivamente o inserir no filho esquerdo
                self.esquerda.inserir(valor)
        else:
            if self.direita is None: # Se ao valor for maior ou igual, deve ir para a direita
                self.direita = Node(valor)
            else: # Caso já exista, chama recursivamente o inserir no filho direito
                self.direita.inserir(valor)

    def em_ordem(self, resultado): # Método para percorrer a árvore em ordem
        if self.esquerda: # Se existir filho à esquerda, percorre primeiro
            self.esquerda.em_ordem(resultado)
        resultado.append(self.valor) # Adiciona o valor atual à lista de resultados
        if self.direita: # Se existir filho à direita, percorre depois
            self.direita.em_ordem(resultado)

    def tree_sort(arr): # Método estático para executar o Tree Sort em ordem crescente
      if not arr: # Se a lista estiver vazia, retorna lista vazia
          return []
      root = Node(arr[0]) # Cria a raiz da árvore com o primeiro elemento da lista
      for valor in arr[1:]: # Insere os demais elementos na árvore
          root.inserir(valor)
      resultado = [] # Cria uma lista para armazenar o resultado ordenado

      root.em_ordem(resultado) # Percorre a árvore em ordem para obter os elementos ordenados
      return resultado # Retorna a lista final em ordem crescente

    def tree_sort_desc(arr): # Método estático para executar o Tree Sort em ordem decrescente
        if not arr: # Se a lista estiver vazia, retorna lista vazia
            return []
        root = Node(arr[0]) # Cria a raiz da árvore com o primeiro elemento da lista
        for valor in arr[1:]: # Insere os demais elementos na árvore
            root.inserir(valor)
        resultado = [] # Cria uma lista para armazenar o resultado ordenado
        root.em_ordem(resultado) # Percorre a árvore em ordem para obter os elementos ordenados
        return resultado[::-1] # Retorna a lista em ordem decrescente

# Demonstração simples

lista = [12, 10, 16, 9, 15, 11, 13, 14]

# Ordenação crescente usando tree_sort
print("Crescente:", Node.tree_sort(lista))

# Ordenação decrescente usando tree_sort_desc
print("Decrescente:", Node.tree_sort_desc(lista))

def gerar_lista(tamanho): # Função para gerar as listas (100, 1000, 10000, 100000)
    return random.sample(range(tamanho * 10), tamanho)

def medir_tempo(funcao, lista): # Função para medir o tempo que a ordenação leva para executar (em milissegundos)
    inicio = time.time()
    funcao(lista)
    fim = time.time()
    return (fim - inicio) * 1000

def testar_metodos(): # Função para testar a ordenação cres e desc
    tamanhos = [100, 1000, 10000, 100000]
    resultados_cresc = []
    resultados_desc = []

    for t in tamanhos:
        lista = gerar_lista(t)

        # Teste para crescente
        tempo_c = medir_tempo(Node.tree_sort, lista)
        resultados_cresc.append(tempo_c)

        # Teste para decrescente
        tempo_d = medir_tempo(Node.tree_sort_desc, lista)
        resultados_desc.append(tempo_d)

        print(f"\nTamanho {t}:")
        print(f"  Crescente: {tempo_c:.4f} ms")
        print(f"  Decrescente: {tempo_d:.4f} ms")

    return tamanhos, resultados_cresc, resultados_desc

def gerar_grafico(): # Função para gerar o gráfico com base nos testes
    tamanhos, cresc, desc = testar_metodos()

    plt.plot(tamanhos, cresc, marker="o", label="Tree Sort Crescente", color="pink")
    plt.plot(tamanhos, desc, marker="o", label="Tree Sort Decrescente", color="cyan")

    plt.xlabel("Tamanho da lista")
    plt.ylabel("Tempo (ms)")
    plt.title("Desempenho do Tree Sort")
    plt.legend()
    plt.grid(True)
    plt.show()

gerar_grafico()